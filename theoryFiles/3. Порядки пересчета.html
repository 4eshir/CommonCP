<font size = 6 face = "Tahoma"><p align = justify>Существует три <a href = "#Порядок пересчета"><a id = "Порядок пересчета">порядка пересчёта</a></a>:
<br><br><b>1) Прямой порядок:</b><br>
Состояния последовательно пересчитываются, исходя из уже посчитанных.
<br><img src = "images\1.png"><br>
То есть i-тый элемент пересчитывается исходя из i-1, i-2 и т. д.<br>
<i>Пример прямого порядка пересчета:</i><br>
#	fib[i] = fib[i - 1] + fib[i - 2];	#<br>
В данной строке кода мы находим i-тое число Фибонначи, исходя из уже найденныхi-1 и 
i-2 чисел. Такой порядок пересчета чаще всего встречается в примерах по динамическому программированию, однако иногда удобнее применять так называемый обратный порядок
<br><br>
<b>2) Обратный порядок:</b><br>
Обновляются все состояния, зависящие от текущего состояния.
<br><img src = "images\2.png"><br>
В обратном порядке пересчета все с точностью до наоборот: i+1, i+2 и другие состояния, исходя из состояния i-ого.
<br><i>Пример обратного порядка пересчета:</i><br>
#	fib[i + 1] += fib[i];	#<br>
#	fib[i + 2] += fib[i];	#<br>
В данном участке кода мы пересчитываем состояния i+1 и i+2, исходя из состояния i.
Первые два порядка пересчета наиболее оптимальны при решении задач методом динамического программирования, поскольку время выполнения таких программ - (О(n^k)), где k–количество вложенных циклов.
Однако, иногда в процессе решения задачи проблематично составить прямой или обратный порядок пересчета. Тогда на помощь приходит «ленивая» динамика.
<br><br>
<b>3) Ленивая динамика:</b><br>
Рекурсивная мемоизированная функция пересчёта динамики. Это что-то вроде поиска в глубину по ацикличному графу состояний, где рёбра — это зависимости между ними. 
<br><img src = "images\3.png"><br>
Проще говоря – в большинстве случаев реализуется рекурсия, с условием выхода на начальных значениях.

 

<br>«Ленивость» заключается в том, что нам не надо просчитывать заранее способ обхода, достаточно написать рекурсию с условием выхода при значении, совпадающим с одним и начальных. Остальную работу выполнит программа. Проблема заключается в большом количестве лишних операций, если каждая из подзадач, связана более чем с одной другой подзадачей.
<br>
Эту проблему в большинстве задач может решить <a id = "Кеширование"><a href = "#Кеширование">кеширование данных</a></a>. Для кеширования небольшого количества данных удобно использовать <a href = "#Хеш-таблица"><a id = "Хеш-таблица">хеш-таблицы</a></a>.
<br><br><i>Пример кеширования данных для решения задачи вычисления n-ого числа Фибоначчи:</i>
<br>#	HashMap<Integer, Integer> cache = new HashMap<Integer, Integer>();			
<br>#	int fcashe(int n){										
<br>#		if(!cache.containsKey(n)){//Нашли ли мы данное значение       
<br>#			cache.put(n, f(n)); //Если нет, то находим и записываем в таблицу   
<br>#		}											
<br>#		return cache.get(n);									
<br>#	}												

</p></font>