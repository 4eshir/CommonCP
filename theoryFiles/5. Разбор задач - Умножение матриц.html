<font size = 6 face = "Tahoma"><p align = justify>
<b>
<a id = "Задача1">Умножение матриц</a>
</b>
<br>
<i>Сведение задачи к подзадачам</i>

Обозначим результат перемножения матриц A(i) A(i+1)...A(j) через A(i...j), где i&le;j. Если i&lt;j, то существует такое k, которое разбивает A(i..j) между матрицами A(K) и A(K+1),
i&le;k&lt;j. То есть для вычисления A(i...j) надо сначала вычислить A(i...k), потом A(k+1...j) и затем их перемножить. Выбор k является аналогом расстановки скобок между матрицами.
Выбрав некоторое k мы свели задачу к двум аналогичным подзадачам для матриц A(i...k) и A(k+1...j).
<br>
<br>
<i>Рекурсивное решение</i>

Обозначим через m[i, j] минимальное количество скалярных умножений для вычисления матрицы A(i...j). Получаем следующее рекуррентное соотношение: 
<img src = "images\matrix1.png">

Объясняется оно просто: для того, чтобы найти произведение матриц A(i...j) при i=j не нужно ничего делать — это и есть сама матрица A(i).
При нетривиальном случае мы перебираем все точки разбиения матрицы A(i...j) на матрицы A(i...k) и A(k+1...j), ищем кол-во операций, необходимое
чтобы их получить и затем перемножаем для получения матрицы A(i...j).(Оно будет равно кол-ву операций, потраченное на решение подзадач + стоимость умножения матриц
A(i...k) * A(k+1...j). Считаем, что размеры матриц заданы в массиве p и размер матрицы A(i) равен p(i-1) * p(i). Как обычно рекурсивный метод нельзя использовать напрямую —
он будет экспоненциальным из-за большого кол-ва перекрывающихся подзадач.

Динамическое программирование

Будем запоминать в двумерном массиве <b>m</b> результаты вычислений для подзадач, чтобы избежать пересчета для уже вычислявшихся подзадач. После вычислений ответ будет в <b>m[1,n]</b>(Сколько перемножений требуется для последовательности матриц от 1 до n — то есть ответ на поставленную задачу).Сложность алгоритма будет O(n^3)
</p></font>